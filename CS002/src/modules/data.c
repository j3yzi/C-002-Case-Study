#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "data.h"
#include "../../../include/models/employee.h"
#include "../../../include/models/student.h"
#include "../../../include/headers/list.h"

// Function to create data directory if it doesn't exist
static int createDataDirectory(void) {
    // Use system command to create directory (works on Windows and Unix)
    // The command will fail silently if directory already exists, which is what we want
    system("mkdir data 2>nul"); // Windows: redirect error to null
    return 0; // Always return success
}

// Function to list all .dat files in the data directory
int listDataFiles(void) {
    // Create data directory if it doesn't exist
    createDataDirectory();
    
    printf("=== Available Data Files ===\n");
    
    // Use system command to list .dat files
    
    // Windows command to list .dat files
    int result = system("dir data\\*.dat /B 2>nul");
    if (result != 0) {
        printf("No .dat files found in the data directory.\n");
        return 0;
    }
    
    printf("=============================\n");
    return 1; // Files found
}

// Function to create output directory if it doesn't exist
static int createOutputDirectory(void) {
    // Use system command to create directory (works on Windows and Unix)
    system("mkdir output 2>nul"); // Windows: redirect error to null
    return 0; // Always return success
}

// Function to get current timestamp for filenames
void getCurrentTimestamp(char* buffer, int bufferSize) {
    // Get current time
    time_t rawtime;
    struct tm * timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    // Format: YYYY-MM-DD_HH-MM-SS
    strftime(buffer, bufferSize, "%Y-%m-%d_%H-%M-%S", timeinfo);
}

// Function to generate payroll report file
int generatePayrollReportFile(const list* employeeList, char* generatedFilePath, int pathBufferSize) {
    if (!employeeList || !employeeList->head || employeeList->size == 0) {
        return -1; // No data to report
    }
    
    // Create output directory if it doesn't exist
    createOutputDirectory();
    
    // Generate timestamp for filename
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    // Create filename with timestamp
    char filename[256];
    snprintf(filename, sizeof(filename), "output/payroll_report-%s.txt", timestamp);
    
    // Copy full path to output parameter
    snprintf(generatedFilePath, pathBufferSize, "%s", filename);
    
    FILE *file = fopen(filename, "w");
    if (!file) {
        return -1; // Failed to create file
    }
    
    // Write header
    fprintf(file, "=== Employee Payroll Report ===\n");
    fprintf(file, "Generated on: %s\n\n", timestamp);
    
    // Write table header
    fprintf(file, "%-12s | %-20s | %-8s | %-10s | %-10s | %-10s | %-10s | %-6s\n",
           "Emp. Number", "Employee Name", "Status", "Basic Pay", "Overtime", "Deductions", "Net Pay", "Hours");
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    
    // Write employee data
    node* current = employeeList->head;
    int count = 0;
    double totalBasicPay = 0.0;
    double totalOvertimePay = 0.0;
    double totalDeductions = 0.0;
    double totalNetPay = 0.0;
    
    if (current != NULL) {
        do {
            Employee* emp = (Employee*)current->data;
            if (emp != NULL) {
                count++;
                
                fprintf(file, "%-12s | %-20s | %-8s | %10.2f | %10.2f | %10.2f | %10.2f | %6d\n",
                       emp->personal.employeeNumber,
                       emp->personal.name.fullName,
                       (emp->employment.status == statusRegular) ? "Regular" : "Casual",
                       emp->payroll.basicPay,
                       emp->payroll.overtimePay,
                       emp->payroll.deductions,
                       emp->payroll.netPay,
                       emp->employment.hoursWorked);
                       
                totalBasicPay += emp->payroll.basicPay;
                totalOvertimePay += emp->payroll.overtimePay;
                totalDeductions += emp->payroll.deductions;
                totalNetPay += emp->payroll.netPay;
            }
            current = current->next;
        } while (current != employeeList->head && current != NULL);
    }
    
    // Write totals
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    fprintf(file, "%-32s | %10.2f | %10.2f | %10.2f | %10.2f |\n",
           "TOTALS:", totalBasicPay, totalOvertimePay, totalDeductions, totalNetPay);
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    fprintf(file, "Total employees: %d\n\n", count);
    
    fprintf(file, "Report generated by Employee Payroll System\n");
    
    fclose(file);
    return count; // Return number of employees processed
}

int saveEmployeeDataFromFile(list* employeeList, const char *filename) {
    if (!employeeList || !filename) {
        return -1; // Invalid parameters
    }
    
    // Create data directory if it doesn't exist
    if (createDataDirectory() != 0) {
        return -1; // Failed to create data directory
    }
    
    // Build full path to data directory (local to executable)
    char fullPath[512];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "wb");
    if (!file) {
        return -1; // Failed to open file for writing
    }
    
    // Write the number of employees first
    int employeeCount = employeeList->size;
    if (fwrite(&employeeCount, sizeof(int), 1, file) != 1) {
        fclose(file);
        return -1; // Failed to write employee count
    }
    
    // If list is empty, we're done
    if (employeeCount == 0 || !employeeList->head) {
        fclose(file);
        return 0;
    }
    
    // Iterate through the linked list and save each employee
    node* current = employeeList->head;
    int savedCount = 0;
    
    // Handle different list types
    if (employeeList->type == SINGLY || employeeList->type == DOUBLY) {
        // Non-circular lists
        while (current != NULL && savedCount < employeeCount) {
            Employee* emp = (Employee*)current->data;
            if (emp) {
                if (fwrite(emp, sizeof(Employee), 1, file) != 1) {
                    fclose(file);
                    return -1; // Failed to write employee data
                }
                savedCount++;
            }
            current = current->next;
        }
    } else {
        // Circular lists
        if (current != NULL) {
            do {
                Employee* emp = (Employee*)current->data;
                if (emp) {
                    if (fwrite(emp, sizeof(Employee), 1, file) != 1) {
                        fclose(file);
                        return -1; // Failed to write employee data
                    }
                    savedCount++;
                }
                current = current->next;
                
                // Safety check to prevent infinite loops
                if (savedCount >= employeeCount) {
                    break;
                }
            } while (current != NULL && current != employeeList->head);
        }
    }
    
    fclose(file);
    return savedCount; // Return number of employees saved
}

list* loadEmployeeDataFromFile(const char* filename, ListType listType) {
    if (!filename) {
        return NULL; // Invalid filename
    }
    
    // Create data directory if it doesn't exist
    if (createDataDirectory() != 0) {
        // If we can't create the directory, still try to create an empty list
        list* employeeList = NULL;
        if (createList(&employeeList, listType) != 0) {
            return NULL;
        }
        return employeeList;
    }
    
    // Build full path to data directory (local to executable)
    char fullPath[512];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "rb");
    if (!file) {
        // File doesn't exist or can't be opened, return NULL to indicate failure
        return NULL;
    }
    
    // Read the number of employees
    int employeeCount;
    if (fread(&employeeCount, sizeof(int), 1, file) != 1) {
        fclose(file);
        return NULL; // Failed to read employee count
    }
    
    // Create the list
    list* employeeList = NULL;
    if (createList(&employeeList, listType) != 0) {
        fclose(file);
        return NULL; // Failed to create list
    }
    
    // If no employees to load, return empty list
    if (employeeCount <= 0) {
        fclose(file);
        return employeeList;
    }
    
    // Load each employee and add to the list
    for (int i = 0; i < employeeCount; i++) {
        // Allocate memory for new employee
        Employee* newEmployee = (Employee*)malloc(sizeof(Employee));
        if (!newEmployee) {
            // Memory allocation failed, cleanup and return NULL
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
        
        // Read employee data from file
        if (fread(newEmployee, sizeof(Employee), 1, file) != 1) {
            // Failed to read employee data, cleanup and return NULL
            free(newEmployee);
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
        
        // Add the employee to the list using addNode
        if (addNode(&employeeList, newEmployee) != 0) {
            // Failed to add node, cleanup and return NULL
            free(newEmployee);
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
    }
    
    fclose(file);
    return employeeList;
}

// Student data management functions

// Function to generate student report file
int generateStudentReportFile(const list* studentList, char* generatedFilePath, int pathBufferSize) {
    if (!studentList || !studentList->head || studentList->size == 0) {
        return -1; // No data to report
    }
    
    // Create output directory if it doesn't exist
    createOutputDirectory();
    
    // Generate timestamp for filename
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    // Create filename with timestamp
    char filename[256];
    snprintf(filename, sizeof(filename), "output/student_report-%s.txt", timestamp);
    
    // Copy full path to output parameter
    snprintf(generatedFilePath, pathBufferSize, "%s", filename);
    
    FILE *file = fopen(filename, "w");
    if (!file) {
        return -1; // Failed to create file
    }
    
    // Write header
    fprintf(file, "=== Student Academic Records Report ===\n");
    fprintf(file, "Generated on: %s\n\n", timestamp);
    
    // Write table header
    fprintf(file, "%-15s | %-25s | %-15s | %-4s | %-12s | %-8s\n",
           "Student No.", "Full Name", "Course", "Year", "Final Grade", "Remarks");
    fprintf(file, "-------------------------------------------------------------------------------------\n");
    
    // Write student data and calculate statistics
    node* current = studentList->head;
    int count = 0;
    int passedCount = 0;
    int failedCount = 0;
    double totalGrade = 0.0;
    double highestGrade = 0.0;
    double lowestGrade = 100.0;
    
    if (current != NULL) {
        do {
            Student* student = (Student*)current->data;
            if (student != NULL) {
                count++;
                
                fprintf(file, "%-15s | %-25s | %-15s | %-4d | %12.2f | %-8s\n",
                       student->personal.studentNumber,
                       student->personal.name.fullName,
                       "Information Technology",
                       student->personal.yearLevel,
                       student->academic.finalGrade,
                       student->academic.remarks);
                
                // Update statistics
                if (strcmp(student->academic.remarks, "Passed") == 0) {
                    passedCount++;
                } else {
                    failedCount++;
                }
                
                totalGrade += student->academic.finalGrade;
                if (student->academic.finalGrade > highestGrade) {
                    highestGrade = student->academic.finalGrade;
                }
                if (student->academic.finalGrade < lowestGrade) {
                    lowestGrade = student->academic.finalGrade;
                }
            }
            current = current->next;
        } while (current != studentList->head && current != NULL);
    }
    
    // Write statistics
    fprintf(file, "-------------------------------------------------------------------------------------\n");
    fprintf(file, "STATISTICS:\n");
    fprintf(file, "Total students: %d\n", count);
    fprintf(file, "Passed: %d (%.1f%%)\n", passedCount, count > 0 ? (passedCount * 100.0) / count : 0.0);
    fprintf(file, "Failed: %d (%.1f%%)\n", failedCount, count > 0 ? (failedCount * 100.0) / count : 0.0);
    fprintf(file, "Average grade: %.2f\n", count > 0 ? totalGrade / count : 0.0);
    fprintf(file, "Highest grade: %.2f\n", highestGrade);
    fprintf(file, "Lowest grade: %.2f\n", lowestGrade);
    fprintf(file, "\nReport generated by CS002 Student Management System\n");
    
    fclose(file);
    return count; // Return number of students processed
}

// Function to save student data to file
int saveStudentDataFromFile(list* studentList, const char *filename) {
    if (!studentList || !filename) {
        return -1; // Invalid parameters
    }
    
    // Create data directory if it doesn't exist
    if (createDataDirectory() != 0) {
        return -1; // Failed to create data directory
    }
    
    // Build full path to data directory
    char fullPath[512];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "wb");
    if (!file) {
        return -1; // Failed to open file for writing
    }
    
    // Write the number of students first
    int studentCount = studentList->size;
    if (fwrite(&studentCount, sizeof(int), 1, file) != 1) {
        fclose(file);
        return -1; // Failed to write student count
    }
    
    // If list is empty, we're done
    if (studentCount == 0 || !studentList->head) {
        fclose(file);
        return 0;
    }
    
    // Iterate through the linked list and save each student
    node* current = studentList->head;
    int savedCount = 0;
    
    // Handle different list types
    if (studentList->type == SINGLY || studentList->type == DOUBLY) {
        // Non-circular lists
        while (current != NULL && savedCount < studentCount) {
            Student* student = (Student*)current->data;
            if (student) {
                if (fwrite(student, sizeof(Student), 1, file) != 1) {
                    fclose(file);
                    return -1; // Failed to write student data
                }
                savedCount++;
            }
            current = current->next;
        }
    } else {
        // Circular lists
        if (current != NULL) {
            do {
                Student* student = (Student*)current->data;
                if (student) {
                    if (fwrite(student, sizeof(Student), 1, file) != 1) {
                        fclose(file);
                        return -1; // Failed to write student data
                    }
                    savedCount++;
                }
                current = current->next;
                
                // Safety check to prevent infinite loops
                if (savedCount >= studentCount) {
                    break;
                }
            } while (current != NULL && current != studentList->head);
        }
    }
    
    fclose(file);
    return savedCount; // Return number of students saved
}

// Function to load student data from file
list* loadStudentDataFromFile(const char* filename, ListType listType) {
    if (!filename) {
        return NULL; // Invalid filename
    }
    
    // Create data directory if it doesn't exist
    if (createDataDirectory() != 0) {
        // If we can't create the directory, still try to create an empty list
        list* studentList = NULL;
        if (createList(&studentList, listType) != 0) {
            return NULL;
        }
        return studentList;
    }
    
    // Build full path to data directory
    char fullPath[512];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "rb");
    if (!file) {
        // File doesn't exist or can't be opened, return NULL to indicate failure
        return NULL;
    }
    
    // Read the number of students
    int studentCount;
    if (fread(&studentCount, sizeof(int), 1, file) != 1) {
        fclose(file);
        return NULL; // Failed to read student count
    }
    
    // Create the list
    list* studentList = NULL;
    if (createList(&studentList, listType) != 0) {
        fclose(file);
        return NULL; // Failed to create list
    }
    
    // If no students to load, return empty list
    if (studentCount <= 0) {
        fclose(file);
        return studentList;
    }
    
    // Load each student and add to the list
    for (int i = 0; i < studentCount; i++) {
        // Allocate memory for new student
        Student* newStudent = (Student*)malloc(sizeof(Student));
        if (!newStudent) {
            // Memory allocation failed, cleanup and return NULL
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        // Read student data from file
        if (fread(newStudent, sizeof(Student), 1, file) != 1) {
            // Failed to read student data, cleanup and return NULL
            free(newStudent);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        // Add the student to the list using addNode
        if (addNode(&studentList, newStudent) != 0) {
            // Failed to add node, cleanup and return NULL
            free(newStudent);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
    }
    
    fclose(file);
    return studentList;
}

// Function to sort students by grade (bubble sort)
int sortStudentsByGrade(list* studentList, int descending) {
    if (!studentList || !studentList->head || studentList->size <= 1) {
        return 0; // Nothing to sort or invalid list
    }
    
    int swapped;
    node* current;
    node* last = NULL;
    
    if (studentList->head == NULL) {
        return 0;
    }
    
    do {
        swapped = 0;
        current = studentList->head;
        
        while (current->next != last && current->next != NULL) {
            Student* currentStudent = (Student*)current->data;
            Student* nextStudent = (Student*)current->next->data;
            
            if (currentStudent && nextStudent) {
                int shouldSwap = descending ? 
                    (currentStudent->academic.finalGrade < nextStudent->academic.finalGrade) :
                    (currentStudent->academic.finalGrade > nextStudent->academic.finalGrade);
                
                if (shouldSwap) {
                    // Swap data pointers
                    void* temp = current->data;
                    current->data = current->next->data;
                    current->next->data = temp;
                    swapped = 1;
                }
            }
            current = current->next;
        }
        last = current;
    } while (swapped);
    
    return 0; // Success
}

// Multi-list management functions

// Function to list employee data files specifically
int listEmployeeDataFiles(void) {
    // Create data directory if it doesn't exist
    createDataDirectory();
    
    printf("=== Available Employee Data Files ===\n");
    
    // Use system command to list .dat files containing "employee" in name
    int result = system("dir data\\*employee*.dat /B 2>nul");
    if (result != 0) {
        printf("No employee .dat files found in the data directory.\n");
        return 0;
    }
    
    printf("=====================================\n");
    return 1; // Files found
}

// Function to list student data files specifically  
int listStudentDataFiles(void) {
    // Create data directory if it doesn't exist
    createDataDirectory();
    
    printf("=== Available Student Data Files ===\n");
    
    // Use system command to list .dat files containing "student" in name
    int result = system("dir data\\*student*.dat /B 2>nul");
    if (result != 0) {
        printf("No student .dat files found in the data directory.\n");
        return 0;
    }
    
    printf("=====================================\n");
    return 1; // Files found
}

// Function to save list with custom name
int saveListWithCustomName(list* dataList, const char* listName, const char* dataType) {
    if (!dataList || !listName || !dataType) {
        return -1; // Invalid parameters
    }
    
    // Generate filename with custom name and data type
    char filename[256];
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    snprintf(filename, sizeof(filename), "%s_%s_%s.dat", dataType, listName, timestamp);
    
    // Save based on data type
    if (strcmp(dataType, "employee") == 0) {
        return saveEmployeeDataFromFile(dataList, filename);
    } else if (strcmp(dataType, "student") == 0) {
        return saveStudentDataFromFile(dataList, filename);
    }
    
    return -1; // Invalid data type
}

// Function to load list with name
list* loadListWithName(const char* filename, const char* dataType, ListType listType) {
    if (!filename || !dataType) {
        return NULL; // Invalid parameters
    }
    
    // Load based on data type
    if (strcmp(dataType, "employee") == 0) {
        return loadEmployeeDataFromFile(filename, listType);
    } else if (strcmp(dataType, "student") == 0) {
        return loadStudentDataFromFile(filename, listType);
    }
    
    return NULL; // Invalid data type
} 