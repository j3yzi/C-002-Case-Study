#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifdef _WIN32
#include <windows.h>
#endif
#include "data.h"
#include "../../include/models/employee.h"
#include "../../include/models/student.h"
#include "../../include/headers/list.h"
#include "../../include/headers/apctxt.h"

// Function to create data directory if it doesn't exist
static int createDataDirectory(void) {
    return appCreateDirectory("data");
}

// Function to create output directory if it doesn't exist
static int createOutputDirectory(void) {
    return appCreateDirectory("output");
}

// Function to list all .dat files in the data directory
int listDataFiles(void) {
    createDataDirectory();
    
    printf("=== Available Data Files ===\n");
    
    int result = appListFiles("data", "*.dat");
    if (result != 1) {
        printf("No .dat files found in the data directory.\n");
        return 0;
    }
    
    printf("=============================\n");
    return 1;
}

// Function to get current timestamp for filenames
void getCurrentTimestamp(char* buffer, const int bufferSize) {
    time_t rawtime;
    struct tm * timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    strftime(buffer, bufferSize, "%Y-%m-%d_%H-%M-%S", timeinfo);
}

// Function to generate payroll report file
int generatePayrollReportFile(const list* employeeList, char* generatedFilePath, const int pathBufferSize) {
    if (!employeeList || !employeeList->head || employeeList->size == 0) {
        return -1;
    }
    
    createOutputDirectory();
    
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    char filename[256];
    snprintf(filename, sizeof(filename), "output/payroll_report-%s.txt", timestamp);
    
    snprintf(generatedFilePath, pathBufferSize, "%s", filename);
    
    FILE *file = fopen(filename, "w");
    if (!file) {
        return -1;
    }
    
    fprintf(file, "=== Employee Payroll Report ===\n");
    fprintf(file, "Generated on: %s\n\n", timestamp);
    
    fprintf(file, "%-12s | %-20s | %-8s | %-10s | %-10s | %-10s | %-10s | %-6s\n",
           "Emp. Number", "Employee Name", "Status", "Basic Pay", "Overtime", "Deductions", "Net Pay", "Hours");
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    
    node* current = employeeList->head;
    int count = 0;
    double totalBasicPay = 0.0;
    double totalOvertimePay = 0.0;
    double totalDeductions = 0.0;
    double totalNetPay = 0.0;
    
    if (current != NULL) {
        do {
            Employee* emp = (Employee*)current->data;
            if (emp != NULL) {
                count++;
                
                fprintf(file, "%-12s | %-20s | %-8s | %10.2f | %10.2f | %10.2f | %10.2f | %6d\n",
                       emp->personal.employeeNumber,
                       emp->personal.name.fullName,
                       (emp->employment.status == statusRegular) ? "Regular" : "Casual",
                       emp->payroll.basicPay,
                       emp->payroll.overtimePay,
                       emp->payroll.deductions,
                       emp->payroll.netPay,
                       emp->employment.hoursWorked);
                       
                totalBasicPay += emp->payroll.basicPay;
                totalOvertimePay += emp->payroll.overtimePay;
                totalDeductions += emp->payroll.deductions;
                totalNetPay += emp->payroll.netPay;
            }
            current = current->next;
        } while (current != employeeList->head && current != NULL);
    }
    
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    fprintf(file, "%-32s | %10.2f | %10.2f | %10.2f | %10.2f |\n",
           "TOTALS:", totalBasicPay, totalOvertimePay, totalDeductions, totalNetPay);
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    fprintf(file, "Total employees: %d\n\n", count);
    
    fprintf(file, "Report generated by PUP Information Management System\n");
    
    fclose(file);
    return count;
}

// Function to generate student report file
int generateStudentReportFile(const list* studentList, char* generatedFilePath, const int pathBufferSize) {
    if (!studentList || !studentList->head || studentList->size == 0) {
        return -1;
    }
    
    createOutputDirectory();
    
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    char filename[256];
    snprintf(filename, sizeof(filename), "output/student_report-%s.txt", timestamp);
    
    snprintf(generatedFilePath, pathBufferSize, "%s", filename);
    
    FILE *file = fopen(filename, "w");
    if (!file) {
        return -1;
    }
    
    fprintf(file, "=== Student Academic Report ===\n");
    fprintf(file, "Generated on: %s\n\n", timestamp);
    
    fprintf(file, "%-12s | %-20s | %-8s | %-6s | %-6s | %-6s | %-6s | %-8s\n",
           "Student No.", "Student Name", "Program", "Year", "Prelim", "Midterm", "Final", "Remarks");
    fprintf(file, "-------------------------------------------------------------------------------------\n");
    
    node* current = studentList->head;
    int count = 0;
    double totalFinalGrade = 0.0;
    int passedCount = 0;
    
    if (current != NULL) {
        do {
            Student* stu = (Student*)current->data;
            if (stu != NULL) {
                count++;
                
                fprintf(file, "%-12s | %-20s | %-8s | %6d | %6.2f | %6.2f | %6.2f | %-8s\n",
                       stu->personal.studentNumber,
                       stu->personal.name.fullName,
                       stu->personal.programCode,
                       stu->personal.yearLevel,
                       stu->academic.prelimGrade,
                       stu->academic.midtermGrade,
                       stu->academic.finalExamGrade,
                       stu->academic.remarks);
                       
                totalFinalGrade += stu->academic.finalGrade;
                if (strcmp(stu->academic.remarks, "Passed") == 0) {
                    passedCount++;
                }
            }
            current = current->next;
        } while (current != studentList->head && current != NULL);
    }
    
    fprintf(file, "-------------------------------------------------------------------------------------\n");
    fprintf(file, "Total students: %d\n", count);
    fprintf(file, "Average grade: %.2f\n", totalFinalGrade / count);
    fprintf(file, "Passed: %d (%.1f%%)\n", passedCount, (passedCount * 100.0) / count);
    fprintf(file, "Failed: %d (%.1f%%)\n", count - passedCount, ((count - passedCount) * 100.0) / count);
    
    fprintf(file, "\nReport generated by PUP Information Management System\n");
    
    fclose(file);
    return count;
}

// Complete implementations for file I/O functions
int saveEmployeeDataFromFile(list* employeeList, const char *filename) {
    if (!employeeList || !filename) {
        return -1;
    }
    
    createDataDirectory();
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "wb");
    if (!file) {
        return -1;
    }
    
    // Write number of employees
    int count = employeeList->size;
    fwrite(&count, sizeof(int), 1, file);
    
    // Write each employee record
    node* current = employeeList->head;
    int saved = 0;
    
    if (current != NULL) {
        do {
            Employee* emp = (Employee*)current->data;
            if (emp != NULL) {
                fwrite(emp, sizeof(Employee), 1, file);
                saved++;
            }
            current = current->next;
        } while (current != employeeList->head && current != NULL);
    }
    
    fclose(file);
    return saved;
}

list* loadEmployeeDataFromFile(const char* filename, ListType listType) {
    if (!filename) {
        return NULL;
    }
    
    // Note: listType parameter reserved for future list type handling
    (void)listType; // Suppress unused parameter warning
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "rb");
    if (!file) {
        return NULL;
    }
    
    // Read number of employees
    int count;
    if (fread(&count, sizeof(int), 1, file) != 1) {
        fclose(file);
        return NULL;
    }
    
    // Create new list
    list* employeeList = NULL;
    if (createEmployeeList(&employeeList) != 0) {
        fclose(file);
        return NULL;
    }
    
    // Read each employee record
    for (int i = 0; i < count; i++) {
        Employee* emp = (Employee*)malloc(sizeof(Employee));
        if (!emp) {
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
        
        if (fread(emp, sizeof(Employee), 1, file) != 1) {
            free(emp);
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
        
        if (createEmployee(emp, &employeeList) != 0) {
            free(emp);
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
    }
    
    fclose(file);
    return employeeList;
}

int saveStudentDataFromFile(list* studentList, const char *filename) {
    if (!studentList || !filename) {
        return -1;
    }
    
    createDataDirectory();
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "wb");
    if (!file) {
        return -1;
    }
    
    // Write number of students
    int count = studentList->size;
    fwrite(&count, sizeof(int), 1, file);
    
    // Write each student record
    node* current = studentList->head;
    int saved = 0;
    
    if (current != NULL) {
        do {
            Student* stu = (Student*)current->data;
            if (stu != NULL) {
                fwrite(stu, sizeof(Student), 1, file);
                saved++;
            }
            current = current->next;
        } while (current != studentList->head && current != NULL);
    }
    
    fclose(file);
    return saved;
}

list* loadStudentDataFromFile(const char* filename, ListType listType) {
    if (!filename) {
        return NULL;
    }
    
    // Note: listType parameter reserved for future list type handling
    (void)listType; // Suppress unused parameter warning
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "rb");
    if (!file) {
        return NULL;
    }
    
    // Read number of students
    int count;
    if (fread(&count, sizeof(int), 1, file) != 1) {
        fclose(file);
        return NULL;
    }
    
    // Create new list
    list* studentList = NULL;
    if (createStudentList(&studentList) != 0) {
        fclose(file);
        return NULL;
    }
    
    // Read each student record
    for (int i = 0; i < count; i++) {
        Student* stu = (Student*)malloc(sizeof(Student));
        if (!stu) {
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        if (fread(stu, sizeof(Student), 1, file) != 1) {
            free(stu);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        if (createStudent(stu, &studentList) != 0) {
            free(stu);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
    }
    
    fclose(file);
    return studentList;
}

// Function to find the middle node of a linked list using fast/slow pointer approach
static node* findMiddleNode(node* head, node* tail) {
    if (!head || head == tail) {
        return head;
    }
    
    node* slow = head;
    node* fast = head->next;
    
    // Fast pointer moves twice as fast as slow pointer
    while (fast != tail && fast->next != tail) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    return slow;
}

// Function to merge two sorted linked lists
static node* mergeSortedLists(node* left, node* right, node* tail, int descending, 
                             int (*compareFunc)(void*, void*, int)) {
    node dummy;
    node* current = &dummy;
    
    // Merge the two lists
    while (left != NULL && right != NULL && left != tail && right != tail) {
        if (compareFunc(left->data, right->data, descending)) {
            current->next = left;
            left = left->next;
        } else {
            current->next = right;
            right = right->next;
        }
        current = current->next;
    }
    
    // Attach the remaining nodes
    if (left != NULL && left != tail) {
        current->next = left;
    } else if (right != NULL && right != tail) {
        current->next = right;
    }
    
    return dummy.next;
}

// Compare function for student grades
static int compareStudentGrades(void* data1, void* data2, int descending) {
    Student* stu1 = (Student*)data1;
    Student* stu2 = (Student*)data2;
    
    if (descending) {
        return stu1->academic.finalGrade >= stu2->academic.finalGrade;
    } else {
        return stu1->academic.finalGrade <= stu2->academic.finalGrade;
    }
}

// Recursive merge sort implementation for linked list
static node* mergeSortList(node* head, node* tail, int descending, 
                          int (*compareFunc)(void*, void*, int)) {
    // Base case: empty list or single node
    if (!head || head == tail || head->next == tail) {
        return head;
    }
    
    // Find the middle node
    node* middle = findMiddleNode(head, tail);
    node* right = middle->next;
    
    // Split the list into two halves
    middle->next = NULL;
    
    // Recursively sort both halves
    node* leftSorted = mergeSortList(head, NULL, descending, compareFunc);
    node* rightSorted = mergeSortList(right, tail, descending, compareFunc);
    
    // Merge the sorted halves
    return mergeSortedLists(leftSorted, rightSorted, tail, descending, compareFunc);
}

int sortStudentsByGrade(list* studentList, const int descending) {
    if (!studentList || studentList->size <= 1) {
        return 0;
    }
    
    // Handle circular lists by temporarily breaking the circle
    node* oldTail = NULL;
    
    if (studentList->type == SINGLY_CIRCULAR || studentList->type == DOUBLY_CIRCULAR) {
        oldTail = studentList->tail;
        studentList->tail->next = NULL;  // Break the circle
    }
    
    // Apply merge sort
    studentList->head = mergeSortList(studentList->head, NULL, descending, compareStudentGrades);
    
    // Update the tail pointer
    node* current = studentList->head;
    while (current && current->next) {
        current = current->next;
    }
    studentList->tail = current;
    
    // Restore circular structure if needed
    if (oldTail) {
        studentList->tail->next = studentList->head;  // Restore the circle
    }
    
    return 1;
}

int listEmployeeDataFiles(void) {
    printf("=== Available Employee Data Files ===\n");
    int result = appListFiles("data", "*employee*.dat");
    if (result != 1) {
        printf("No employee .dat files found.\n");
        return 0;
    }
    return 1;
}

int getEmployeeDataFileNames(char fileNames[][256], int maxFiles) {
    if (!fileNames || maxFiles <= 0) {
        return 0;
    }
    
    createDataDirectory();
    
    // Construct the search path
    char searchPath[512];
    snprintf(searchPath, sizeof(searchPath), "data\\*employee*.dat");
    
    WIN32_FIND_DATA findFileData;
    HANDLE hFind = FindFirstFile(searchPath, &findFileData);
    
    if (hFind == INVALID_HANDLE_VALUE) {
        return 0; // No files found
    }
    
    int fileCount = 0;
    
    do {
        // Skip directories and ensure we don't exceed maxFiles
        if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fileCount < maxFiles) {
            strncpy(fileNames[fileCount], findFileData.cFileName, 255);
            fileNames[fileCount][255] = '\0'; // Ensure null termination
            fileCount++;
        }
    } while (FindNextFile(hFind, &findFileData) != 0 && fileCount < maxFiles);
    
    FindClose(hFind);
    return fileCount;
}

int listStudentDataFiles(void) {
    printf("=== Available Student Data Files ===\n");
    int result = appListFiles("data", "*student*.dat");
    if (result != 1) {
        printf("No student .dat files found.\n");
        return 0;
    }
    return 1;
}

int getStudentDataFileNames(char fileNames[][256], int maxFiles) {
    if (!fileNames || maxFiles <= 0) {
        return 0;
    }
    
    createDataDirectory();
    
    // Construct the search path
    char searchPath[512];
    snprintf(searchPath, sizeof(searchPath), "data\\*student*.dat");
    
    WIN32_FIND_DATA findFileData;
    HANDLE hFind = FindFirstFile(searchPath, &findFileData);
    
    if (hFind == INVALID_HANDLE_VALUE) {
        return 0; // No files found
    }
    
    int fileCount = 0;
    
    do {
        // Skip directories and ensure we don't exceed maxFiles
        if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && fileCount < maxFiles) {
            strncpy(fileNames[fileCount], findFileData.cFileName, 255);
            fileNames[fileCount][255] = '\0'; // Ensure null termination
            fileCount++;
        }
    } while (FindNextFile(hFind, &findFileData) != 0 && fileCount < maxFiles);
    
    FindClose(hFind);
    return fileCount;
}

int saveListWithCustomName(list* dataList, const char* listName, const char* dataType) {
    if (!dataList || !listName || !dataType) {
        return -1;
    }
    
    // Generate simple filename without timestamp
    char filename[256];
    snprintf(filename, sizeof(filename), "%s_%s.dat", dataType, listName);
    
    if (strcmp(dataType, "employee") == 0) {
        return saveEmployeeDataFromFile(dataList, filename);
    } else if (strcmp(dataType, "student") == 0) {
        return saveStudentDataFromFile(dataList, filename);
    }
    
    return -1;
}

list* loadListWithName(const char* filename, const char* dataType, ListType listType) {
    if (!filename || !dataType) {
        return NULL;
    }
    
    if (strcmp(dataType, "employee") == 0) {
        return loadEmployeeDataFromFile(filename, listType);
    } else if (strcmp(dataType, "student") == 0) {
        return loadStudentDataFromFile(filename, listType);
    }
    
    return NULL;
} 