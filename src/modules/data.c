#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "data.h"
#include "../../include/models/employee.h"
#include "../../include/models/student.h"
#include "../../include/headers/list.h"

// Function to create data directory if it doesn't exist
static int createDataDirectory(void) {
    system("mkdir data 2>nul"); // Windows: redirect error to null
    return 0;
}

// Function to create output directory if it doesn't exist
static int createOutputDirectory(void) {
    system("mkdir output 2>nul"); // Windows: redirect error to null
    return 0;
}

// Function to list all .dat files in the data directory
int listDataFiles(void) {
    createDataDirectory();
    
    printf("=== Available Data Files ===\n");
    
    int result = system("dir data\\*.dat /B 2>nul");
    if (result != 0) {
        printf("No .dat files found in the data directory.\n");
        return 0;
    }
    
    printf("=============================\n");
    return 1;
}

// Function to get current timestamp for filenames
void getCurrentTimestamp(char* buffer, int bufferSize) {
    time_t rawtime;
    struct tm * timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    strftime(buffer, bufferSize, "%Y-%m-%d_%H-%M-%S", timeinfo);
}

// Function to generate payroll report file
int generatePayrollReportFile(const list* employeeList, char* generatedFilePath, int pathBufferSize) {
    if (!employeeList || !employeeList->head || employeeList->size == 0) {
        return -1;
    }
    
    createOutputDirectory();
    
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    char filename[256];
    snprintf(filename, sizeof(filename), "output/payroll_report-%s.txt", timestamp);
    
    snprintf(generatedFilePath, pathBufferSize, "%s", filename);
    
    FILE *file = fopen(filename, "w");
    if (!file) {
        return -1;
    }
    
    fprintf(file, "=== Employee Payroll Report ===\n");
    fprintf(file, "Generated on: %s\n\n", timestamp);
    
    fprintf(file, "%-12s | %-20s | %-8s | %-10s | %-10s | %-10s | %-10s | %-6s\n",
           "Emp. Number", "Employee Name", "Status", "Basic Pay", "Overtime", "Deductions", "Net Pay", "Hours");
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    
    node* current = employeeList->head;
    int count = 0;
    double totalBasicPay = 0.0;
    double totalOvertimePay = 0.0;
    double totalDeductions = 0.0;
    double totalNetPay = 0.0;
    
    if (current != NULL) {
        do {
            Employee* emp = (Employee*)current->data;
            if (emp != NULL) {
                count++;
                
                fprintf(file, "%-12s | %-20s | %-8s | %10.2f | %10.2f | %10.2f | %10.2f | %6d\n",
                       emp->personal.employeeNumber,
                       emp->personal.name.fullName,
                       (emp->employment.status == statusRegular) ? "Regular" : "Casual",
                       emp->payroll.basicPay,
                       emp->payroll.overtimePay,
                       emp->payroll.deductions,
                       emp->payroll.netPay,
                       emp->employment.hoursWorked);
                       
                totalBasicPay += emp->payroll.basicPay;
                totalOvertimePay += emp->payroll.overtimePay;
                totalDeductions += emp->payroll.deductions;
                totalNetPay += emp->payroll.netPay;
            }
            current = current->next;
        } while (current != employeeList->head && current != NULL);
    }
    
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    fprintf(file, "%-32s | %10.2f | %10.2f | %10.2f | %10.2f |\n",
           "TOTALS:", totalBasicPay, totalOvertimePay, totalDeductions, totalNetPay);
    fprintf(file, "------------------------------------------------------------------------------------------------------\n");
    fprintf(file, "Total employees: %d\n\n", count);
    
    fprintf(file, "Report generated by PUP Information Management System\n");
    
    fclose(file);
    return count;
}

// Function to generate student report file
int generateStudentReportFile(const list* studentList, char* generatedFilePath, int pathBufferSize) {
    if (!studentList || !studentList->head || studentList->size == 0) {
        return -1;
    }
    
    createOutputDirectory();
    
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    char filename[256];
    snprintf(filename, sizeof(filename), "output/student_report-%s.txt", timestamp);
    
    snprintf(generatedFilePath, pathBufferSize, "%s", filename);
    
    FILE *file = fopen(filename, "w");
    if (!file) {
        return -1;
    }
    
    fprintf(file, "=== Student Academic Report ===\n");
    fprintf(file, "Generated on: %s\n\n", timestamp);
    
    fprintf(file, "%-12s | %-20s | %-8s | %-6s | %-6s | %-6s | %-6s | %-8s\n",
           "Student No.", "Student Name", "Program", "Year", "Prelim", "Midterm", "Final", "Remarks");
    fprintf(file, "-------------------------------------------------------------------------------------\n");
    
    node* current = studentList->head;
    int count = 0;
    double totalFinalGrade = 0.0;
    int passedCount = 0;
    
    if (current != NULL) {
        do {
            Student* stu = (Student*)current->data;
            if (stu != NULL) {
                count++;
                
                fprintf(file, "%-12s | %-20s | %-8s | %6d | %6.2f | %6.2f | %6.2f | %-8s\n",
                       stu->personal.studentNumber,
                       stu->personal.name.fullName,
                       (stu->personal.programCode == PROG_IT) ? "IT" : "CS",
                       stu->personal.yearLevel,
                       stu->academic.prelimGrade,
                       stu->academic.midtermGrade,
                       stu->academic.finalExamGrade,
                       stu->academic.remarks);
                       
                totalFinalGrade += stu->academic.finalGrade;
                if (strcmp(stu->academic.remarks, "Passed") == 0) {
                    passedCount++;
                }
            }
            current = current->next;
        } while (current != studentList->head && current != NULL);
    }
    
    fprintf(file, "-------------------------------------------------------------------------------------\n");
    fprintf(file, "Total students: %d\n", count);
    fprintf(file, "Average grade: %.2f\n", totalFinalGrade / count);
    fprintf(file, "Passed: %d (%.1f%%)\n", passedCount, (passedCount * 100.0) / count);
    fprintf(file, "Failed: %d (%.1f%%)\n", count - passedCount, ((count - passedCount) * 100.0) / count);
    
    fprintf(file, "\nReport generated by PUP Information Management System\n");
    
    fclose(file);
    return count;
}

// Complete implementations for file I/O functions
int saveEmployeeDataFromFile(list* employeeList, const char *filename) {
    if (!employeeList || !filename) {
        return -1;
    }
    
    createDataDirectory();
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "wb");
    if (!file) {
        return -1;
    }
    
    // Write number of employees
    int count = employeeList->size;
    fwrite(&count, sizeof(int), 1, file);
    
    // Write each employee record
    node* current = employeeList->head;
    int saved = 0;
    
    if (current != NULL) {
        do {
            Employee* emp = (Employee*)current->data;
            if (emp != NULL) {
                fwrite(emp, sizeof(Employee), 1, file);
                saved++;
            }
            current = current->next;
        } while (current != employeeList->head && current != NULL);
    }
    
    fclose(file);
    return saved;
}

list* loadEmployeeDataFromFile(const char* filename, ListType listType) {
    if (!filename) {
        return NULL;
    }
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "rb");
    if (!file) {
        return NULL;
    }
    
    // Read number of employees
    int count;
    if (fread(&count, sizeof(int), 1, file) != 1) {
        fclose(file);
        return NULL;
    }
    
    // Create new list
    list* employeeList = NULL;
    if (createEmployeeList(&employeeList) != 0) {
        fclose(file);
        return NULL;
    }
    
    // Read each employee record
    for (int i = 0; i < count; i++) {
        Employee* emp = (Employee*)malloc(sizeof(Employee));
        if (!emp) {
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
        
        if (fread(emp, sizeof(Employee), 1, file) != 1) {
            free(emp);
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
        
        if (createEmployee(emp, &employeeList) != 0) {
            free(emp);
            fclose(file);
            destroyList(&employeeList, freeEmployee);
            return NULL;
        }
    }
    
    fclose(file);
    return employeeList;
}

int saveStudentDataFromFile(list* studentList, const char *filename) {
    if (!studentList || !filename) {
        return -1;
    }
    
    createDataDirectory();
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "wb");
    if (!file) {
        return -1;
    }
    
    // Write number of students
    int count = studentList->size;
    fwrite(&count, sizeof(int), 1, file);
    
    // Write each student record
    node* current = studentList->head;
    int saved = 0;
    
    if (current != NULL) {
        do {
            Student* stu = (Student*)current->data;
            if (stu != NULL) {
                fwrite(stu, sizeof(Student), 1, file);
                saved++;
            }
            current = current->next;
        } while (current != studentList->head && current != NULL);
    }
    
    fclose(file);
    return saved;
}

list* loadStudentDataFromFile(const char* filename, ListType listType) {
    if (!filename) {
        return NULL;
    }
    
    char fullPath[256];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "rb");
    if (!file) {
        return NULL;
    }
    
    // Read number of students
    int count;
    if (fread(&count, sizeof(int), 1, file) != 1) {
        fclose(file);
        return NULL;
    }
    
    // Create new list
    list* studentList = NULL;
    if (createStudentList(&studentList) != 0) {
        fclose(file);
        return NULL;
    }
    
    // Read each student record
    for (int i = 0; i < count; i++) {
        Student* stu = (Student*)malloc(sizeof(Student));
        if (!stu) {
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        if (fread(stu, sizeof(Student), 1, file) != 1) {
            free(stu);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        if (createStudent(stu, &studentList) != 0) {
            free(stu);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
    }
    
    fclose(file);
    return studentList;
}

int sortStudentsByGrade(list* studentList, int descending) {
    if (!studentList || studentList->size <= 1) {
        return 0;
    }
    
    // Simple bubble sort for students by final grade
    int swapped;
    node* current;
    node* last = NULL;
    
    do {
        swapped = 0;
        current = studentList->head;
        
        while (current->next != last && current->next != studentList->head) {
            Student* stu1 = (Student*)current->data;
            Student* stu2 = (Student*)current->next->data;
            
            int shouldSwap = descending ? 
                (stu1->academic.finalGrade < stu2->academic.finalGrade) :
                (stu1->academic.finalGrade > stu2->academic.finalGrade);
                
            if (shouldSwap) {
                // Swap data pointers
                void* temp = current->data;
                current->data = current->next->data;
                current->next->data = temp;
                swapped = 1;
            }
            current = current->next;
        }
        last = current;
    } while (swapped);
    
    return 1;
}

int listEmployeeDataFiles(void) {
    printf("=== Available Employee Data Files ===\n");
    int result = system("dir data\\*employee*.dat /B 2>nul");
    if (result != 0) {
        printf("No employee .dat files found.\n");
        return 0;
    }
    return 1;
}

int listStudentDataFiles(void) {
    printf("=== Available Student Data Files ===\n");
    int result = system("dir data\\*student*.dat /B 2>nul");
    if (result != 0) {
        printf("No student .dat files found.\n");
        return 0;
    }
    return 1;
}

int saveListWithCustomName(list* dataList, const char* listName, const char* dataType) {
    if (!dataList || !listName || !dataType) {
        return -1;
    }
    
    // Generate timestamped filename
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    char filename[256];
    snprintf(filename, sizeof(filename), "%s_%s_%s.dat", dataType, listName, timestamp);
    
    if (strcmp(dataType, "employee") == 0) {
        return saveEmployeeDataFromFile(dataList, filename);
    } else if (strcmp(dataType, "student") == 0) {
        return saveStudentDataFromFile(dataList, filename);
    }
    
    return -1;
}

list* loadListWithName(const char* filename, const char* dataType, ListType listType) {
    if (!filename || !dataType) {
        return NULL;
    }
    
    if (strcmp(dataType, "employee") == 0) {
        return loadEmployeeDataFromFile(filename, listType);
    } else if (strcmp(dataType, "student") == 0) {
        return loadStudentDataFromFile(filename, listType);
    }
    
    return NULL;
} 