#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "data.h"
#include "../../../include/models/student.h"
#include "../../../include/headers/list.h"

// Function to create data directory if it doesn't exist
static int createDataDirectory(void) {
    // Use system command to create directory (works on Windows and Unix)
    // The command will fail silently if directory already exists, which is what we want
    system("mkdir data 2>nul"); // Windows: redirect error to null
    return 0; // Always return success
}

// Function to list all .dat files in the data directory
int listDataFiles(void) {
    // Create data directory if it doesn't exist
    createDataDirectory();
    
    printf("=== Available Data Files ===\n");
    
    // Use system command to list .dat files
    
    // Windows command to list .dat files
    int result = system("dir data\\*.dat /B 2>nul");
    if (result != 0) {
        printf("No .dat files found in the data directory.\n");
        return 0;
    }
    
    printf("=============================\n");
    return 1; // Files found
}

// Function to create output directory if it doesn't exist
static int createOutputDirectory(void) {
    // Use system command to create directory (works on Windows and Unix)
    system("mkdir output 2>nul"); // Windows: redirect error to null
    return 0; // Always return success
}

// Function to get current timestamp for filenames
void getCurrentTimestamp(char* buffer, int bufferSize) {
    // Get current time
    time_t rawtime;
    struct tm * timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    // Format: YYYY-MM-DD_HH-MM-SS
    strftime(buffer, bufferSize, "%Y-%m-%d_%H-%M-%S", timeinfo);
}

// Function to generate student report file
int generateStudentReportFile(const list* studentList, char* generatedFilePath, int pathBufferSize) {
    if (!studentList || !studentList->head || studentList->size == 0) {
        return -1; // No data to report
    }
    
    // Create output directory if it doesn't exist
    createOutputDirectory();
    
    // Generate timestamp for filename
    char timestamp[32];
    getCurrentTimestamp(timestamp, sizeof(timestamp));
    
    // Create filename with timestamp
    char filename[256];
    snprintf(filename, sizeof(filename), "output/student_report-%s.txt", timestamp);
    
    // Copy full path to output parameter
    snprintf(generatedFilePath, pathBufferSize, "%s", filename);
    
    FILE *file = fopen(filename, "w");
    if (!file) {
        return -1; // Failed to create file
    }
    
    // Write header
    fprintf(file, "=== Student Records Report ===\n");
    fprintf(file, "Generated on: %s\n\n", timestamp);
    
    // Write table header
    fprintf(file, "%-12s | %-25s | %-8s | %-4s | %-11s | %-7s\n",
           "Student No.", "Full Name", "Course", "Year", "Final Grade", "Remarks");
    fprintf(file, "------------------------------------------------------------------------------\n");
    
    // Write student data
    node* current = studentList->head;
    int count = 0;
    float totalGrade = 0.0f;
    int passedCount = 0;
    int failedCount = 0;
    
    if (current != NULL) {
        do {
            Student* student = (Student*)current->data;
            if (student != NULL) {
                count++;
                
                fprintf(file, "%-12s | %-25s | %-8s | %-4d | %11.2f | %-7s\n",
                       student->personal.studentNumber,
                       student->personal.name.fullName,
                       (student->personal.programCode == PROG_IT) ? "IT" : "CS",
                       student->personal.yearLevel,
                       student->academic.finalGrade,
                       student->academic.remarks);
                       
                totalGrade += student->academic.finalGrade;
                if (strcmp(student->academic.remarks, "Passed") == 0) {
                    passedCount++;
                } else {
                    failedCount++;
                }
            }
            current = current->next;
        } while (current != studentList->head && current != NULL);
    }
    
    // Write summary
    fprintf(file, "------------------------------------------------------------------------------\n");
    fprintf(file, "Total students: %d\n", count);
    fprintf(file, "Students passed: %d\n", passedCount);
    fprintf(file, "Students failed: %d\n", failedCount);
    if (count > 0) {
        fprintf(file, "Average grade: %.2f\n", totalGrade / count);
    }
    fprintf(file, "------------------------------------------------------------------------------\n");
    
    fprintf(file, "\nReport generated by Student Records Management System\n");
    
    fclose(file);
    return count; // Return number of students processed
}

int saveStudentDataFromFile(list* studentList, const char *filename) {
    if (!studentList || !filename) {
        return -1; // Invalid parameters
    }
    
    // Create data directory if it doesn't exist
    if (createDataDirectory() != 0) {
        return -1; // Failed to create data directory
    }
    
    // Build full path to data directory (local to executable)
    char fullPath[512];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "wb");
    if (!file) {
        return -1; // Failed to open file for writing
    }
    
    // Write the number of students first
    int studentCount = studentList->size;
    if (fwrite(&studentCount, sizeof(int), 1, file) != 1) {
        fclose(file);
        return -1; // Failed to write student count
    }
    
    // If list is empty, we're done
    if (studentCount == 0 || !studentList->head) {
        fclose(file);
        return 0;
    }
    
    // Iterate through the linked list and save each student
    node* current = studentList->head;
    int savedCount = 0;
    
    // Handle different list types
    if (studentList->type == SINGLY || studentList->type == DOUBLY) {
        // Non-circular lists
        while (current != NULL && savedCount < studentCount) {
            Student* student = (Student*)current->data;
            if (student) {
                if (fwrite(student, sizeof(Student), 1, file) != 1) {
                    fclose(file);
                    return -1; // Failed to write student data
                }
                savedCount++;
            }
            current = current->next;
        }
    } else {
        // Circular lists
        if (current != NULL) {
            do {
                Student* student = (Student*)current->data;
                if (student) {
                    if (fwrite(student, sizeof(Student), 1, file) != 1) {
                        fclose(file);
                        return -1; // Failed to write student data
                    }
                    savedCount++;
                }
                current = current->next;
                
                // Safety check to prevent infinite loops
                if (savedCount >= studentCount) {
                    break;
                }
            } while (current != NULL && current != studentList->head);
        }
    }
    
    fclose(file);
    return savedCount; // Return number of students saved
}

list* loadStudentDataFromFile(const char* filename, ListType listType) {
    if (!filename) {
        return NULL; // Invalid filename
    }
    
    // Create data directory if it doesn't exist
    if (createDataDirectory() != 0) {
        // If we can't create the directory, still try to create an empty list
        list* studentList = NULL;
        if (createList(&studentList, listType) != 0) {
            return NULL;
        }
        return studentList;
    }
    
    // Build full path to data directory (local to executable)
    char fullPath[512];
    snprintf(fullPath, sizeof(fullPath), "data/%s", filename);
    
    FILE *file = fopen(fullPath, "rb");
    if (!file) {
        // File doesn't exist or can't be opened, return NULL to indicate failure
        return NULL;
    }
    
    // Read the number of students
    int studentCount;
    if (fread(&studentCount, sizeof(int), 1, file) != 1) {
        fclose(file);
        return NULL; // Failed to read student count
    }
    
    // Create the list
    list* studentList = NULL;
    if (createList(&studentList, listType) != 0) {
        fclose(file);
        return NULL; // Failed to create list
    }
    
    // If no students to load, return empty list
    if (studentCount <= 0) {
        fclose(file);
        return studentList;
    }
    
    // Load each student and add to the list
    for (int i = 0; i < studentCount; i++) {
        // Allocate memory for new student
        Student* newStudent = (Student*)malloc(sizeof(Student));
        if (!newStudent) {
            // Memory allocation failed, cleanup and return NULL
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        // Read student data from file
        if (fread(newStudent, sizeof(Student), 1, file) != 1) {
            // Failed to read student data, cleanup and return NULL
            free(newStudent);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
        
        // Add the student to the list using addNode
        if (addNode(&studentList, newStudent) != 0) {
            // Failed to add node, cleanup and return NULL
            free(newStudent);
            fclose(file);
            destroyList(&studentList, freeStudent);
            return NULL;
        }
    }
    
    fclose(file);
    return studentList;
}

// Simple bubble sort implementation for sorting students by final grade
int sortStudentsByGrade(list* studentList, bool descending) {
    if (!studentList || !studentList->head || studentList->size <= 1) {
        return 0; // Nothing to sort
    }
    
    // Convert to array for easier sorting
    Student** students = (Student**)malloc(studentList->size * sizeof(Student*));
    if (!students) {
        return -1; // Memory allocation failed
    }
    
    // Fill array with student pointers
    node* current = studentList->head;
    int index = 0;
    
    if (studentList->type == SINGLY || studentList->type == DOUBLY) {
        // Non-circular lists
        while (current != NULL && index < studentList->size) {
            students[index] = (Student*)current->data;
            current = current->next;
            index++;
        }
    } else {
        // Circular lists
        if (current != NULL) {
            do {
                students[index] = (Student*)current->data;
                current = current->next;
                index++;
            } while (current != studentList->head && index < studentList->size);
        }
    }
    
    // Bubble sort
    for (int i = 0; i < index - 1; i++) {
        for (int j = 0; j < index - i - 1; j++) {
            bool shouldSwap;
            if (descending) {
                shouldSwap = students[j]->academic.finalGrade < students[j + 1]->academic.finalGrade;
            } else {
                shouldSwap = students[j]->academic.finalGrade > students[j + 1]->academic.finalGrade;
            }
            
            if (shouldSwap) {
                Student* temp = students[j];
                students[j] = students[j + 1];
                students[j + 1] = temp;
            }
        }
    }
    
    // Update the linked list with sorted data
    current = studentList->head;
    index = 0;
    
    if (studentList->type == SINGLY || studentList->type == DOUBLY) {
        // Non-circular lists
        while (current != NULL && index < studentList->size) {
            current->data = students[index];
            current = current->next;
            index++;
        }
    } else {
        // Circular lists
        if (current != NULL) {
            do {
                current->data = students[index];
                current = current->next;
                index++;
            } while (current != studentList->head && index < studentList->size);
        }
    }
    
    free(students);
    return 0; // Success
} 